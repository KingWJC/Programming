## Design Pattern(23种)

## 创建型模式

这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

#### 工厂模式

1. 静态工厂(简单工厂)

   1. 定义：提供一个工厂类，可以根据参数完成对象的创建。

   2. 优点：

      1）实现了封装和部分解耦：客户端不用关注对象以及对象创建的过程。

      2）实现复用：创建对象不需要单独实例化，而是通过工厂类直接获取实例。

      3）实现多态：通过传入不同的参数来实现多态，达到实例化不同对象的目的。

   3. 缺点：

      1）违反开闭原则：实例化对象的逻辑都在一个类中，需求变化时，需要修改工厂类。

      2）不方便扩展子类。

2. 工厂方法

   1. 定义：定义一个用于创建对象的接口，让子类决定实例化哪个类。

   2. 优点：

      1）在简单工厂的基础上遵循了开闭原则，又进行了解耦，工厂类分为具体的工厂类，将实例化某一类对象具体细分给对应的工厂。

   3. 缺点：

      1）每增加一个产品，就要额外开发一个工厂。

3. 抽象工厂

   1. 定义：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。

   2. 实现：是对工厂模式又进行了一层抽象，不单单是像工厂模式只生成一类产品，而是一系列产品，并且可以像零件一样灵活配置给各工厂。(产品族：两个相互影响的产品线。)

      ​           将工厂模式的主体类的抽象工厂方法提为一个接口，用对象合成取代了类继承。更高灵活度, 复杂度。

   3. 应用：
      常用于模板方法(控制反转)。
      抽象工厂的获取常用依赖查找和注入
      主要目的是遵循依赖倒置原则

   4. 优点：

      1) 分离了具体的类
      Abstract Factory 模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。

      2) 使得易于交换产品系列
      一个具体工厂类在一个应用中仅出现一次—即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。

      3) 有利于产品的一致性
      当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。

   5. 缺点：

      1) 难以支持新种类的产品
      难以扩展抽象工厂以生产新种类的产品，这是因为AbstractFactory接口确定了可以被创建的产品集合。 支持新种类的产品就需要扩展该工厂接口，这将涉及 AbstractFactory类及其所有子类的改变。

4. 保变原则：保护的变化是产品的来源。

#### 建造者模式

1. 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
2. 解析：
   1. 分离复杂对象的构建和表示。
   2. 同样的构建过程可以创建不同的表示。
3. 保变原则：被保护的变化是产品的制作细节。
4. 用法：内部构建和外部构建。

#### 单例模式

1. 定义：该类负责创建自己的对象，同时确保只有单个对象被创建。
   这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
2. 单例模式解决的问题
   保证一个类仅有一个实例，并提供一个访问它的全局访问点。防止一个全局使用的类频繁地创建与销毁，节省资源，方便管理。
3. 单例模式注意事项
   单例类只能有一个实例。单例类必须自己创建自己的唯一实例，其他任何地方无法通过构造方法创建对象，也意味着需要构造方法私有化。单例类必须给所有其他对象提供这一实例。
4. 使用场景
   网站的计数器，一般也是采用单例模式实现，否则难以同步。
   数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。
   操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
5. 代码实现：
   1. 单例模式又分为懒汉模式和饿汉模式，（双重校验锁，枚举和静态内部类。）
   2. 两种的区别在于是不是启动的时候创建对象：
          饿汉模式不管是否需要对象，都先创建好。
          懒汉模式是在需要对象的时候，进行对象的创建。
   3. 本质区别是时间和空间的取舍：
          懒汉模式是用时间换空间，启动时候不需要创建对象，节省了空间，但是访问对象的时候要判断是否已经创建对象，会浪费一些时间。
          饿汉模式是用空间换时间，启动的时候创建对象，浪费了一些空间，但是访问的时候，不需要创建对象和判断对象是否存在，节省了时间，提高了效率。
   4. 懒汉模式存在一些问题
          在多线程的情况下，多个线程同时调用getInstance方法，可能会创建多个对象，违背了单例模式只有一个实例的原则，需要对getInstance进行同步处理。同步处理后，保证只会创建一个单例，但是效率很低，是对整个getInstance方法加锁，一旦对象已经创建，每次只能有一个线程访问对象，可以通过双检锁的方式进行优化，既可以保证只会创建一个对象，同时又允许多个线程访问实例。
6. 优缺点
   优点：在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。由于在系统内存中只存在一个对象，因此可以 节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。
   缺点：不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”

#### 原型模式

定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

实现：编程语言自带。

1. JAVA需要实现标记型接口Cloneable, 是一个空接口，相当于一个标志，没有实现该接口的类是无法调用clone()方法的。这里的标志判断是在native方法中进行。
2. 重写clone()方法，设为public。克隆对象的clone()方法并不属于Cloneable接口，它是Object类的一个方法. 
3. 没有重写Object的clone()方法且没有实现Cloneable接口的实例上调用clone方法，会报`CloneNotSupportedException`异常
4. .NET实现接口ICloneable，并重写clone方法。

使用场景：部分属性已确定，需要大量对象时，可以节省指定属性的代码语句。

浅克隆和深克隆：

- 对于非基本类型的变量（如自定义的类），浅复制保存的仅仅是对象的引用，导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象，对非基本类型的变量的操作会相互影响。
- 深克隆在clone()方法中除了要克隆自身对象，还要对其非基本数据类型的成员变量克隆一遍
- String类型不需要进行深克隆(即使使用new)：String存储在常量池中，修改克隆的对象的String类型，只会更改String类型的引用，使它指向常量池中新的字符串，不影响原型的数据。但如果使用StringBuilder时，需要深克隆。

深克隆的方式有两种：

1. 使用Cloneable接口
   第一步，克隆的类要实现Cloneable接口和重写Object的clone()方法；
   第二步，先调用super.clone()方法克隆出一个新对象，然后手动给克隆出来的对象的非基本数据类型的成员变量赋值。
2. 使用序列化
   克隆对象实现Serializable接口。先对对象进行序列化，紧接着马上反序列化。需要注意克隆对象的非基本数据类型成员也需要实现Serializable接口，否则会报错，成员无法被序列化。

final

#### 享元模式

针对软件的运行质量，对于值语义对象，通过共享机制，减少对象的创建，

关键：抽象出一类对象的内在的，不因环境而异的状态，封装后作为共享单元。

例子：String。池化技术(线程池。连接池)

#### 桥梁模式

信息隐藏只能将接口与实现从逻辑上分离，而桥梁模式能从物理上分离，使一个类同时拥有多种实现，并可以动态切换。

分离抽象和具体，用聚合的方式连接抽象和具体。双维度扩展。

代码结构为：两个类型层级形成的聚合层级。使用了类间的聚合关系、继承、覆写

解决：
1.类继承的缺点(继承有N层) ，重写，扩展不易。
2.抽象父类包含两个变化点，导致相互组合后，子类过多，类爆炸。
   如女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购。
   颜色类（Color）是一个维度，定义为实现化角色，它有两个具体实现化角色：黄色和红色，通过 getColor() 方法可以选择颜色；
   包类（Bag）是另一个维度，定义为抽象化角色，它有两个扩展抽象化角色：挎包和钱包，它包含了颜色类对象，通过 getName() 方法可以选择相关颜色的挎包和钱包。

最佳案例：
	Father类有一个方法A，Son继承了这个方法，然后GrandSon也继承了这个方法，问题是突然有一天Son要重写父类的这个方法，修改的风险就太大！因为GrandSon要用从Father继承过来的方法A，如果你修改了，那就要修改Son和GrandSon之间的关系。
	桥梁模式描述了类间弱关联关系，还说上面的那个例子，Father类完全可以把可能会变化的方法放出去，Son子类要拥有这个方法很简单，桥梁搭过去，获得这个方法，GrandSon也一样，即使你Son子类不像使用这个方法也没关系，对GrandSon不产生影响，他不是从Son中继承来的方法。

#### 适配器模式

目的：接口转换器，解决服务提供者和使用者之间接口不兼容的问题。

特点：改变对象的接口(只做接口转换)，保持对象的职责

区别：桥梁模式重点是分解，让接口和实现分离，可维护性。
			适配器模式重点是结合，让无关的类结合共事，可重用性。迪米特法则。

例子：InputStreamReader

#### 代理模式

特点：保持对象的接口，限制接口的服务

类别：虚拟代理，远程代理，缓存代理，智能引用，保护代理。

#### 外观模式

特点：

1. 封装多个对象，并改变被包装对象的接口。
2. 提供层更高的抽象和粒度更粗的服务，统一和简化外界对子系统的访问。

#### 装饰器模式

目的：动态增减功能，减少子类膨胀。

方式：继承改为合成。静态改为动态。1对1关系

特点：改变对象的职责，保持对象的接口，增强接口的服务

#### 复合模式

目的：为了抽象理解和同一管理数量众多，类型不同的树形结构

方式：化不同为相同，化多个为一个。1对多关系。

区别：与装饰器模式一样，都是使用类型层级和聚合层级来构造更大的复合结构。
			装饰器模式是退化的复合模式。目的不相同。

特点：

1. 开放式的递归合成
2. 树形层级结构，分为透明型(并集)和安全型(交集)
3. 不同类型的组件，建立物理关系(聚合层级), 并建立逻辑关系(类型层级),保证操作接口的一致性，如布局管理器的抽象。

#### 责任链模式

#### 命令模式



#### 模板模式

定义一个i算法的骨架，把某些步骤留给子类去定义实现。

#### 策略模式

