### 类，构造函数，属性

类是一类事物，对象是其实例。万物皆对象，实例，instance。

创建类自动调用构造函数，默认提供一个空的构造函数。

### 操作对象

创建new。生成一个引用和一个对象。

1. 引用，存储对象的逻辑地址（C++指针，java引用，python变量，win32句柄。），其大小由操作系统决定：32位和64位系统，内存寻址范围为32位，或64位大小。
   - 32位系统的内存地址最大为，2的32次幂，所以内存最多支持4个G。
   - 64位系统则支持内存更大，2的64次幂。
2. 对象：对象的起始地址由引用里的地址来确定，对象的大小由类型确定。对象的范围因此确定。

用指针指向对象，然后对对象内的属性和方法进行访问。

不同指针可以指向同一内存块。

### 对象的内存回收

java/.net/python 由垃圾收集器GC自动回收。引用无初始化，则值为空。

C++：手动回收

- 忘了回收，内存泄漏：
  - 如对象的回收，只回收对象所占的内存空间，但不会回收属性引用指向的内存空间。需要增加类内的析构函数，对象回收时自动调用析构函数。
  - 类内的属性，也就是指针，无初始化的时候，指定的值是随机的。所以需要判断是否初始化，然后再回收。
- 回收多次，数据丢失。

内存：堆和栈。

- New 出来的对象在堆上。堆里的需要垃圾回收。
- 栈上的对象，在方法结束后，方法内相关的所有变量和对象自动删除。

### 方法

1. 方法名也是指针(C++函数指针)，指向方法的具体内容中的代码块。

2. 通过引用或指针访问成员方法。

3. 方法的绑定：通过对象调用的方法名找到方法的代码块的过程。binding

4. 方法调用有两类，动态方法调用与静态方法调用

5. 编译时 vs 运行时

   - compile time binding: 编译时/静态绑定。java文件=>class文件
     - 如：static ,final, private.构造方法，执行效率更高。
   - run-time/dynamic binding: 运行时/动态绑定。main函数开始运行到结束期间。
     - Java中大多数方法都是动态绑定/运行期绑定。

6. 静态绑定和动态绑定的区别：

   1. 静态绑定：编译期间，就可以通过方法名，确定唯一的代码块。不受继承的影响。
   2. 动态绑定：继承+重写后，父类引用，调用的方法名，在编译期间，会指向多个方法代码块。唯有运行时，实例化对象，知道是哪个类的对象，才能确定唯一的代码块。（父类引用指向子类对象，指向重写的方法体，而不是本身的方法体）

7. 深入理解方法的执行：

   1. 编译后，生成class文件，在硬盘上存储，
      1. class中包含方法表和方法的实现内容，
      2. 方法表中记录类内所有的方法名（如：构造方法，自定义方法）。
   2. 运行时，new对象之前，加载到内存里，
   3. 使用引用访问方法。
   4. 根据引用的类型，在内存中找到对应的class。
   5. 这个class的方法表中找到方法名。
   6. 再找到指向的方法代码块，执行。

   **对象中不包含方法，只有属性：方法存在类里**

   **因为同一个类的方法编译完成后的代码都是一样的 ，所以类的所有对象共用一个。**

| 方法重载和方法重写 | 位置 | 方法名 | 参数表         | 返回值         | 访问修饰符       |
| ------------------ | ---- | ------ | -------------- | -------------- | ---------------- |
| 方法重写           | 子类 | 相同   | 相同或是其父类 | 相同或是其子类 | 不能比父类更严格 |
| 方法重载           | 同类 | 相同   | 不相同         | 无关           | 无关             |

### 封装，继承，多态

封装：信息隐藏和访问控制。

继承：构造子类对象前，先构造父类对象。通过父类引用只能看到共有的属性和方法。

多态Polymorphism：

1. 定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

2. 实现的方式：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

   方法重载（类内部之间的多态）：不同的参数列表、返回值类型

   方法重写（父类与子类之间的多态）: 相同的参数列表和返回类型，协变和逆变。

   **继承**发生后，子类对父类的实现方法不满意，进行**方法的重写**，**父类引用可以指向子类对象**，调用方法时，引用指向哪个对象，就调用哪个类的方法。

3. 作用：消除类型之间的耦合关系，软件的可扩展性就来源于多态。

4. 存在的三个必要条件
   一、要有继承；
   二、要有重写；
   三、父类引用指向子类对象。
5. 继承是多态的基础，多态是继承的目的。

